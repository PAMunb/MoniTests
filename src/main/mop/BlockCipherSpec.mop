package mop;

import java.security.Key;
import javax.crypto.Cipher;

import br.unb.cic.mop.jca.eh.*;
import static br.unb.cic.mop.jca.util.CipherTransformationUtil.*;
import br.unb.cic.mop.jca.util.ExecutionContext;


/**
 * BlockCipherSpec
 *
 * A JavaMOP specification of the correct usage of the
 * javax.crypto.Cipher class. Note, currently, we are only
 * addressing a partial specification for block ciphers.
 *
 * @see https://github.com/CROSSINGTUD/Crypto-API-Rules/blob/master/JavaCryptographicArchitecture/src/Cipher.crysl
 */
BlockCipherSpec() {

   event g1 after(String transformation): call(public static Cipher Cipher.getInstance(String)) && args(transformation)
   && condition(isValid(transformation)) { }

   event invalidGetInstance after(String transformation): call(public static Cipher Cipher.getInstance(String)) && args(transformation)
      && condition(!isValid(transformation)) {
        ErrorCollector.instance().addError(new ErrorDescription(ErrorType.UnsafeAlgorithm, "" + __LOC,
                "expecting one of {AES/CBC/PKCS5Padding, AES/PCBC/ISO10126Padding, ...} but found " + transformation + "."));
   }

   event i3 after(int mode, java.security.Key key): call(public void Cipher.init(int, java.security.Key))
      && args(mode, key)
      && condition(ExecutionContext.instance().validate(ExecutionContext.Property.GENERATED_KEY, key))  { }

   event u1 before(byte[] plainText): call(public byte[] Cipher.update(byte[])) && args(plainText)  { }

   event f1 after():
        (call(public byte[] Cipher.doFinal())
         || call(public byte[] Cipher.doFinal(byte[])) ) {  }

   ere : g1 i3 u1 f1

   @fail {
        ErrorCollector.instance().addError(new ErrorDescription(ErrorType.InvalidSequenceOfMethodCalls, "" + __LOC));
	    __RESET;
   }
}
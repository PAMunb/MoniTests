package mop;

import java.security.Key;
import javax.crypto.Cipher;
import java.security.SecureRandom;
import java.security.spec.AlgorithmParameterSpec;

import java.nio.ByteBuffer;
import br.unb.cic.mop.jca.eh.*;
import static br.unb.cic.mop.jca.util.CipherTransformationUtil.*;
import br.unb.cic.mop.jca.util.ExecutionContext;


/**
 * CipherSpec
 *
 * A JavaMOP specification of the correct usage of the
 * javax.crypto.Cipher class.
 *
 * @see https://github.com/CROSSINGTUD/Crypto-API-Rules/blob/master/JavaCryptographicArchitecture/src/Cipher.crysl
 */
CipherSpec(Cipher c) {

   Cipher cipher = null;
   String transformation = "";

   event g1 after(String transformation) returning(Cipher c):
     call(public static Cipher Cipher.getInstance(String)) &&
     args(transformation) &&
     condition(isValid(transformation)) {
       this.transformation = transformation;
       cipher = c;
   }

   event g2 after(String transformation, String provider) returning(Cipher c):
      call(public static Cipher Cipher.getInstance(String, String)) &&
      args(transformation, provider) &&
      condition(isValid(transformation)) {
        this.transformation = transformation;
        cipher = c;
   }


 //  event invalidGetInstance after(String transformation) returning(Cipher c):
 //  call(public static Cipher Cipher.getInstance(String)) &&
 //    args(transformation) &&
 //    condition(!isValid(transformation)) {
 //       ErrorCollector.instance().addError(new ErrorDescription(ErrorType.UnsafeAlgorithm, "" + __LOC,
 //               "expecting one of {AES/CBC/PKCS5Padding, AES/PCBC/ISO10126Padding, ...} but found " + transformation + "."));
 //  }

   event init before(Cipher c):
     call(public void Cipher.init(..)) &&
     target(c) { }

   event u1 before(byte[] plainText, Cipher c):
     call(public byte[] Cipher.update(byte[])) &&
     args(plainText) &&
     target(c) { }

   event wkb1 after(Cipher c) returning(byte[] wrappedKeyBytes):
     call(byte[] Cipher.wrap(Key)) &&
     target(c) {
        ExecutionContext.instance().setProperty(Property.WRAPPED_KEY, wrappedKeyBytes);
   }

   event f1 after(Cipher c) returning(byte[] cipherText):
     call(public byte[] Cipher.doFinal()) &&
     target(c) {
      ExecutionContext.instance().setProperty(Property.ENCRYPTED, cipherText);
   }

   event f2 after(Cipher c) returning(byte[] cipherText):
     call(public byte[] Cipher.doFinal(..)) &&
     target(c) {
       ExecutionContext.instance().setProperty(Property.ENCRYPTED, cipherText);
   }

    event f5 after(byte[] plainText, int offset, int len, byte[] cipherText, Cipher c):
      call(public int Cipher.doFinal(byte[], int, int, byte[])) &&
      args(plainText, offset, len, cipherText) &&
      target(c) {
         ExecutionContext.instance().setProperty(Property.ENCRYPTED, cipherText);
    }

    event f6 after(byte[] plainText, int offset, int len, byte[] cipherText, int cipherOffset, Cipher c):
      call(public int Cipher.doFinal(byte[], int, int, byte[], int)) &&
      args(plainText, offset, len, cipherText, cipherOffset) &&
      target(c) {
        ExecutionContext.instance().setProperty(Property.ENCRYPTED, cipherText);
    }

    event f7 after(ByteBuffer plainTextBuffer, ByteBuffer cipherTextBuffer, Cipher c):
       call(public int Cipher.doFinal(ByteBuffer, ByteBuffer)) &&
       args(plainTextBuffer, cipherTextBuffer) &&
       target(c) {
         ExecutionContext.instance().setProperty(Property.ENCRYPTED, cipherTextBuffer);
    }

   fsm :
     start [
        g1 -> s1
        g2 -> s1
     ]
     s1 [
       init -> s2
     ]
     s2 [
       wkb1 -> end
       f2   -> end
       f5   -> end
       f6   -> end
       f7   -> end
       u1   -> s3
     ]
     s3 [
       f1 -> end
       f2 -> end
       f5 -> end
       f6 -> end
       f7 -> end
     ]
     end [
        wkb1 -> end
        f2   -> end
        f5   -> end
        f6   -> end
        f7   -> end
        u1   -> s3
     ]

   alias match1 = end

   @fail {
        ErrorCollector.instance().addError(new ErrorDescription(ErrorType.InvalidSequenceOfMethodCalls, "" + __LOC));
	    __RESET;
   }

   @match1 {
        ExecutionContext.instance().setObjectAsInAcceptingState(cipher);
   }
}
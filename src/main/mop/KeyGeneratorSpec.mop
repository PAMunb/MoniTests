package mop;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import java.security.SecureRandom;
import java.security.spec.AlgorithmParameterSpec;

KeyGeneratorSpec(KeyGenerator k) {

    List<String> algorithms = Arrays.asList("AES", "HmacSHA256", "HmacSHA384",
    "HmacSHA512");

    event g1 after(String alg) returning(KeyGenerator k): call(public static KeyGenerator KeyGenerator.getInstance(String))
      && args(alg) && condition(algorithms.contains(alg)) { }

    event unsafeAlgorithm after(String alg) returning(KeyGenerator k): call(public static KeyGenerator KeyGenerator.getInstance(String))
      && args(alg) && condition(!algorithms.contains(alg))  {
        ErrorCollector.instance().addError(new ErrorDescription(ErrorType.UnsafeAlgorithm, "" + __LOC,
        "one of" + String.join(",", algorithms) + " but found " + alg + "."));
    }

    event g2 after(String alg, String prov) returning(KeyGenerator k):
      call(public static KeyGenerator KeyGenerator.getInstance(String, String))
      && args(alg, prov) && condition(!algorithms.contains(alg)) { }

    event init before(KeyGenerator k):
       ( call(public void KeyGenerator.init(int)) ||
         call(public void KeyGenerator.init(int, SecureRandom)) ||
         call(public void KeyGenerator.init(AlgorithmParameterSpec)) ||
         call(public void KeyGenerator.init(AlgorithmParameterSpec, SecureRandom)) ||
         call(public void KeyGenerator.init(SecureRandom))
       ) && target(k) { }

    event gk1 after(KeyGenerator k): call(public SecretKey KeyGenerator.generateKey()) && target(k) { }

    ere : (g1 | g2) init gk1

    @fail {
        ErrorCollector.instance().addError(new ErrorDescription(ErrorType.InvalidSequenceOfMethodCalls, "" + __LOC));
        __RESET;
    }
}
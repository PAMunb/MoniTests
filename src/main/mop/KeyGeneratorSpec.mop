package mop;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import java.security.SecureRandom;
import java.security.spec.AlgorithmParameterSpec;

KeyGeneratorSpec(KeyGenerator k) {
    String hashingAlgorithm = "";

    List<String> algorithms = Arrays.asList("AES", "HmacSHA256", "HmacSHA384",
    "HmacSHA512");

    List<int> validAESKeySizes = Arrays.asList(128, 192, 256);

    event g1 after(String alg) returning(KeyGenerator k): call(public static KeyGenerator KeyGenerator.getInstance(String))
      && args(alg) && condition(algorithms.contains(alg)) {
        hashingAlgorithm = alg;
        }

    event unsafeAlgorithm after(String alg) returning(KeyGenerator k): call(public static KeyGenerator KeyGenerator.getInstance(String))
      && args(alg) && condition(!algorithms.contains(alg))  {
        ErrorCollector.instance().addError(new ErrorDescription(ErrorType.UnsafeAlgorithm, "" + __LOC,
        "one of" + String.join(",", algorithms) + " but found " + alg + "."));
    }

    event g2 after(String alg, String prov) returning(KeyGenerator k):
      call(public static KeyGenerator KeyGenerator.getInstance(String, String))
      && args(alg, prov) && condition(!algorithms.contains(alg)) { }

    event init before(KeyGenerator k):
       ( call(public void KeyGenerator.init(int)) ||
         call(public void KeyGenerator.init(int, SecureRandom)) ||
         call(public void KeyGenerator.init(AlgorithmParameterSpec)) ||
         call(public void KeyGenerator.init(AlgorithmParameterSpec, SecureRandom)) ||
         call(public void KeyGenerator.init(SecureRandom))
       ) && target(k) { }

    event invalidAESKeySize before(int keySize):
        ( call(public void KeyGenerator.init(int)) ||
          call(public void KeyGenerator.init(int, SecureRandom))
        ) && args(alg, keySize) && condition(hashingAlgorithm == "AES" && !validAESKeySizes.contains(keySize)) {
            ErrorCollector.instance().addError(new ErrorDescription(ErrorType.InvalidKeySize, "" + __LOC,
            "one of" + Arrays.toString(validAESKeySizes) + " but found " + keySize.toString() + "."));
        }

    event gk1 after(KeyGenerator k): call(public SecretKey KeyGenerator.generateKey()) && target(k) { }

    ere : (g1 | g2) init gk1

    @fail {
        ErrorCollector.instance().addError(new ErrorDescription(ErrorType.InvalidSequenceOfMethodCalls, "" + __LOC));
        __RESET;
    }
}
package mop;

import javax.crypto.Mac;

import br.unb.cic.mop.jca.util.ExecutionContext;
import java.security.spec.AlgorithmParameterSpec;

MacSpec() {

        List<String> algorithms = Arrays.asList("HmacSHA256", "HmacSHA384", "HmacSHA512", "HmacPBESHA1",
           "PBEWithHmacSHA1", "PBEWithHmacSHA224", "PBEWithHmacSHA256", "PBEWithHmacSHA384", "PBEWithHmacSHA512");

        event g1 after(String alg) returning(Mac m):
          call(public static Mac Mac.getInstance(String)) &&
          args(alg) &&
          condition(algorithms.contains(alg)) { }

  //      event g2 after(String alg) returning(Mac m):
  //        call(public static Mac Mac.getInstance(String, ..)) &&
  //        args(alg) &&
  //        condition(algorithms.contains(alg)) { }

        event g3 after(String alg) returning(Mac m):
          call(public static Mac Mac.getInstance(String)) &&
          args(alg) &&
          condition(!algorithms.contains(alg)) {
            ErrorCollector.instance().addError(new ErrorDescription(ErrorType.UnsafeAlgorithm, "" + __LOC,
            "one of " + String.join(",", algorithms) + " but found " + alg + "."));
        }

        event i1 before(java.security.Key key):
          call(public void Mac.init(java.security.Key)) &&
          args(key) &&
          condition(ExecutionContext.instance().validate(ExecutionContext.Property.GENERATED_KEY, key)) { }

        event i2 after(java.security.Key key, java.security.spec.AlgorithmParameterSpec params):
          call(public void Mac.init(java.security.Key, java.security.spec.AlgorithmParameterSpec)) &&
          args(key, params) &&
          condition(ExecutionContext.instance().validate(ExecutionContext.Property.GENERATED_KEY, key))  { }

        event update after():
          call(public void Mac.update(..)) { }

        event f1 after() returning(byte[] output): call(byte[] Mac.doFinal(..)) {
           ExecutionContext.instance().setProperty(Property.GENERATED_MAC, output);
        }
        event f2 after(byte[] output, int outOffset):
          call(void Mac.doFinal(byte[], int)) &&
          args(output, outOffset) {
            ExecutionContext.instance().setProperty(Property.GENERATED_MAC, output);
        }

        ere : g1 (i1 | i2) ((f1 | f2) | (update* (f1 | f2)))

        @fail {
            ErrorCollector.instance().addError(new ErrorDescription(ErrorType.InvalidSequenceOfMethodCalls, "" + __LOC));
            ExecutionContext.instance().remove(Property.GENERATED_MAC);
            __RESET;
        }
}
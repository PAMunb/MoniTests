package mop;

import java.security.MessageDigest;
import java.util.List;

import br.unb.cic.mop.jca.eh.*;
import br.unb.cic.mop.jca.util.ExecutionContext;
import br.unb.cic.mop.jca.util.ExecutionContext.Property;

// The MessageDigestSpec specifies
// the correct usage of the MessageDigest
// class (from the JCA specification).
MessageDigestSpec() {

    List<String> algorithms = Arrays.asList("SHA-256", "SHA-384", "SHA-512");
    MessageDigest md = null;

	event g1 after(String alg) returning(MessageDigest digest):
	  call(public static MessageDigest MessageDigest.getInstance(String))
	  && args(alg) && condition(algorithms.contains(alg.toUpperCase()))
        {
	  md = digest;
	}

	event g2 after(String alg):
	  call(public static MessageDigest MessageDigest.getInstance(String))
    	  && args(alg) && condition(!algorithms.contains(alg.toUpperCase()))
        {
          ErrorCollector.instance().addError(new ErrorDescription(ErrorType.UnsafeAlgorithm, "" + __LOC,
             "one of {SHA-256, SHA-384, SHA-512} but found " + alg + "."));
        }

	event update after(): call(* MessageDigest.update(byte[])) { }

	event reset before(): call(* MessageDigest.reset(..)) { }

	event digest after() returning(byte[] out): call(public byte[] MessageDigest.digest()) {
	    ExecutionContext.instance().setProperty(Property.DIGESTED, out);
	}
 		
	ere : g1 update (update* reset* digest)*

	@fail {
           ErrorCollector.instance().addError(new ErrorDescription(ErrorType.InvalidSequenceOfMethodCalls, "" + __LOC));
           ExecutionContext.instance().unsetObjectAsInAcceptingState(md);
           ExecutionContext.instance().remove(Property.DIGESTED);
           System.out.println("calling the reset on failure");
           __RESET;
	}

	@match {
           ExecutionContext.instance().setObjectAsInAcceptingState(md);
	}
}






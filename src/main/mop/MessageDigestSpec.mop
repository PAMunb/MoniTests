package mop;

import java.security.MessageDigest;
import java.security.Provider;
import java.util.List;

import br.unb.cic.mop.jca.eh.*;
import br.unb.cic.mop.jca.util.ExecutionContext;
import br.unb.cic.mop.jca.util.ExecutionContext.Property;

MessageDigestSpec(MessageDigest digester) {
	MessageDigest md = null;
	List<String> safeAlgorithms = Arrays.asList("SHA-256", "SHA-384", "SHA-512");

	event getInstanceSafe after(String alg) returning(MessageDigest digest):
		call(public static MessageDigest MessageDigest.getInstance(String))
		&& args(alg) && condition(safeAlgorithms.contains(alg.toUpperCase())) {
			md = digest;
		}

	/*
	We had to introduce this event because the agent would not compile. If we have to capture parameters passed into
	after(), the agent fails to compile if the parameters passed do not match the ones in && args(alg)
	 */
	event getInstanceUsingProviderSafe after(String alg, Provider prov) returning(MessageDigest digest):
		call(public static MessageDigest MessageDigest.getInstance(String, Provider))
		&& args(alg, prov) && condition(safeAlgorithms.contains(alg.toUpperCase())) {
			md = digest;
		}

	event getInstanceUnsafe after(String alg):
		(call(public static MessageDigest MessageDigest.getInstance(String)) ||
		 call(public static MessageDigest MessageDigest.getInstance(String, Provider)))

		&& args(alg) && condition(!safeAlgorithms.contains(alg.toUpperCase())) {
			ErrorCollector.instance().addError(new ErrorDescription(ErrorType.UnsafeAlgorithm, "Line: " + __LOC,
			"one of {SHA-256, SHA-384, SHA-512} but found " + alg + "."));
		}

	event update after(MessageDigest digester):
		(call(* MessageDigest.update(byte[])) ||
		 call(* MessageDigest.update(byte))) && target(digester) {
			System.out.println("Updating...");
		}

	event reset before(MessageDigest digester):
		call(* MessageDigest.reset(..)) && target(digester) {

		}

	event defaultDigest after(MessageDigest digester) returning(byte[] out):
		call(public byte[] MessageDigest.digest()) && target(digester) {
			ExecutionContext.instance().setProperty(Property.DIGESTED, out);
		}

	event digestWithoutUpdate after(MessageDigest digester) returning(byte[] out):
		call(public byte[] MessageDigest.digest(byte[])) && target(digester) {
			ExecutionContext.instance().setProperty(Property.DIGESTED, out);
			System.out.println("Digesting byte array...");
		}

	ere: (getInstanceSafe | getInstanceUsingProviderSafe) (digestWithoutUpdate | (update+ defaultDigest))+

@fail {
			ErrorCollector.instance().addError(new ErrorDescription(ErrorType.InvalidSequenceOfMethodCalls, "" + __LOC));
			ExecutionContext.instance().unsetObjectAsInAcceptingState(md);
			ExecutionContext.instance().remove(Property.DIGESTED);
			__RESET;
		}

@match {
			ExecutionContext.instance().setObjectAsInAcceptingState(md);
			System.out.println("****");
		}

}
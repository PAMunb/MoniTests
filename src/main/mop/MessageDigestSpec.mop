package mop;

import java.security.MessageDigest;
import java.security.Provider;
import java.util.List;

import br.unb.cic.mop.jca.eh.*;
import br.unb.cic.mop.jca.util.ExecutionContext;
import br.unb.cic.mop.jca.util.ExecutionContext.Property;

// The MessageDigestSpec specifies
// the correct usage of the MessageDigest
// class (from the JCA specification).
MessageDigestSpec() {
	MessageDigest md = null;
    List<String> safeAlgorithms = Arrays.asList("SHA-256", "SHA-384", "SHA-512");

	event getInstanceSafe after(String alg) returning(MessageDigest digest):
		call(public static MessageDigest MessageDigest.getInstance(String))
		  && args(alg) && condition(safeAlgorithms.contains(alg.toUpperCase())) {
			md = digest;
		  }

	event getInstanceUsingProviderSafe after(String alg, Provider prov) returning(MessageDigest digest):
		call(public static MessageDigest MessageDigest.getInstance(String, Provider))
		  && args(alg, prov) && condition(safeAlgorithms.contains(alg.toUpperCase())) {
			md = digest;
		  }

	event getInstanceUnsafe after(String alg):
	  call(public static MessageDigest MessageDigest.getInstance(String))
	  	&& args(alg) && condition(!safeAlgorithms.contains(alg.toUpperCase())) {
          ErrorCollector.instance().addError(new ErrorDescription(ErrorType.UnsafeAlgorithm, "Line: " + __LOC,
             "one of {SHA-256, SHA-384, SHA-512} but found " + alg + "."));
        }

//	event getInstanceUsingProviderUnsafe after(String alg, Provider prov) returning(MessageDigest digest):
//	  call(public static MessageDigest MessageDigest.getInstance(String, Provider))
//		&& args(alg, prov) && condition(!safeAlgorithms.contains(alg.toUpperCase())) {
//			ErrorCollector.instance().addError(new ErrorDescription(ErrorType.UnsafeAlgorithm, "Line: " + __LOC,
//				"one of {SHA-256, SHA-384, SHA-512} but found " + alg + "."));
//		}

	event update after():
		(call(* MessageDigest.update(byte[])) ||
		 call(* MessageDigest.update(byte)))	 { }

//	event reset before(): call(* MessageDigest.reset(..)) { }

	event defaultDigest after() returning(byte[] out):
	 call(public byte[] MessageDigest.digest())  {
	    ExecutionContext.instance().setProperty(Property.DIGESTED, out);
	 }
//
	event digestByteArray after() returning(byte[] out):
	 call(public byte[] MessageDigest.digest(byte[]))  {
		System.out.println("Calling digest...");
		ExecutionContext.instance().setProperty(Property.DIGESTED, out);
	 }

		ere: (getInstanceSafe | getInstanceUnsafe | getInstanceUsingProviderSafe) (digestByteArray | (update+ (defaultDigest)))+

		@fail {
			ErrorCollector.instance().addError(new ErrorDescription(ErrorType.InvalidSequenceOfMethodCalls, "" + __LOC));
			ExecutionContext.instance().unsetObjectAsInAcceptingState(md);
			ExecutionContext.instance().remove(Property.DIGESTED);
			System.out.println("calling the reset on failure");
			__RESET;
		}

		@match {
			ExecutionContext.instance().setObjectAsInAcceptingState(md);
		}
//	fsm:
//		initial [
//			getInstanceSafe -> instantiated
//			getInstanceUnsafe -> instantiated
//			getInstanceUsingProviderSafe -> instantiated
//		]
//		instantiated [
//			update -> updated
//			digestByteArray -> digested
//		]
//		updated [
//			update -> updated
//			reset -> updated
//			defaultDigest -> digested
//			digestByteArray -> digested
//		]
//		digested [
//			update -> updated
//		]
//
//		alias accepting_state = digested
//
//		@accepting_state {
//			System.out.println("Call sequence is acceptable");
//			__RESET;
//		}

//		@fail {
//			System.out.println("Call sequence is not acceptable");
//			__RESET;
//		}
}






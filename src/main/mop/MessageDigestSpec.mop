package mop;

import java.security.MessageDigest;
import java.util.List;

import br.unb.cic.mop.jca.eh.*;
import br.unb.cic.mop.jca.util.ExecutionContext;
import br.unb.cic.mop.jca.util.ExecutionContext.Property;

// The MessageDigestSpec specifies
// the correct usage of the MessageDigest
// class (from the JCA specification).
MessageDigestSpec() {
	MessageDigest md = null;
    List<String> safeAlgorithms = Arrays.asList("SHA-256", "SHA-384", "SHA-512");

	event getInstanceSafe after(String alg) returning(MessageDigest digest):
	  call(public static MessageDigest MessageDigest.getInstance(String))
		&& args(alg) && condition(safeAlgorithms.contains(alg.toUpperCase())) {
			md = digest;
		}

	event getInstanceUnsafe after(String alg):
	  call(public static MessageDigest MessageDigest.getInstance(String))
	  	&& args(alg) && condition(!safeAlgorithms.contains(alg.toUpperCase())) {
          ErrorCollector.instance().addError(new ErrorDescription(ErrorType.UnsafeAlgorithm, "Line: " + __LOC,
             "one of {SHA-256, SHA-384, SHA-512} but found " + alg + "."));
        }

	event update after(): call(* MessageDigest.update(byte[])) { }

	event reset before(): call(* MessageDigest.reset(..)) { }

	event digest after() returning(byte[] out):
	 (call(public byte[] MessageDigest.digest()) || call(public byte[] MessageDigest.digest(byte[])))  {
	    ExecutionContext.instance().setProperty(Property.DIGESTED, out);
		ExecutionContext.instance().setObjectAsInAcceptingState(md);
	 }

	fsm:
		initial [
			getInstanceSafe -> instantiated
			getInstanceUnsafe -> instantiated
		]
		instantiated [
			update -> updated
		]
		updated [
			update -> updated
			reset -> updated
			digest -> digested
		]
		digested [

		]

		alias accepting_state = digested

		@accepting_state {
			System.out.println("Call sequence is acceptable");
			__RESET;
		}

		@fail {
			System.out.println("Call sequence is not acceptable");
			__RESET;
		}
}






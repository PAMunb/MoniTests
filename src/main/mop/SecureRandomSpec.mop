package mop;

import java.security.SecureRandom;

import br.unb.cic.mop.jca.eh.*;
import br.unb.cic.mop.jca.util.ExecutionContext;


SecureRandomSpec(SecureRandom r) {

    SecureRandom sr;
    List<String> algorithms = Arrays.asList("SHA1PRNG", "Windows-PRNG", "NativePRNG",
        "NativePRNGBlocking", "NativePRNGNonBlocking", "PKCS11");

    // this event captures the following events in the original CrySL specification.
    //  - c1: SecureRandom();
    //  - c2: SecureRandom(..);
    event c1 after() returning(SecureRandom r): call(public SecureRandom.new(..)) {
      sr = r;
    }

    // this event captures the following events in the original CrySL specification.
    //  - g1: getInstance(algorithm);
    //  - g2: getInstance(algorithm, _);
    event g1 after(String alg) returning(SecureRandom r):
      call(public static SecureRandom SecureRandom.getInstance(String))
      && args(alg)
      && condition(algorithms.contains(alg)) {
       sr = r;
    }

    // CrySL gI: getInstanceStrong() event
    event g2 after() returning(SecureRandom r):
      call(public static SecureRandom SecureRandom.getInstanceStrong()) {
      sr = r;
    }

    // getInstance with an invalid algorithm.
    event g3 after(String alg) returning(SecureRandom r):
      call(public static SecureRandom SecureRandom.getInstance(String, ..))
      && args(alg)
      && condition(!algorithms.contains(alg))
    {
        ErrorCollector.instance().addError(new ErrorDescription(ErrorType.UnsafeAlgorithm, "" + __LOC,
         "one of " + String.join(",", algorithms) + " but found " + alg + "."));
    }

    event setSeed after(SecureRandom r):
      (call(public void SecureRandom.setSeed(long)) || call(public void SecureRandom.setSeed(byte[])))
      && target(r) {  }

    event genSeed after(SecureRandom r) returning(byte[] seed):
      call(public byte[] SecureRandom.generateSeed(int))
      && target(r) {
        ExecutionContext.instance().setProperty(Property.RANDOMIZED, seed);
    }

    event next before(SecureRandom r):
      (call(public int SecureRandom.nextInt(int))
       || call(public int SecureRandom.nextInt())
       || call(public void SecureRandom.nextBytes(byte[]))) && target(r) { }

    // TODO: Due to additional test case, we might enable the following ere
    //   (g1 | g2) ((setSeed (generateSeed | next)*) | (generateSeed | next)*)

    // ere : (g1 | g2) (((genSeed | next)) | (setSeed (genSeed | next)*))+

    fsm :
      start [
         c1 -> init
         g1 -> init
         g2 -> init
      ]
      init [
         c1      -> init
         genSeed -> end
         setSeed -> end
         next    -> end
      ]
      end [
         genSeed -> end
         setSeed -> end
         next    -> end
      ]

    alias match1 = init
    alias match2 = end

    @match1 {
        System.out.println("*******");
        ExecutionContext.instance().setObjectAsInAcceptingState(sr);
        ExecutionContext.instance().setProperty(Property.RANDOMIZED, sr);
    }
}